import type { CancellationToken, TextEditor, Uri } from 'vscode';
import { ProgressLocation } from 'vscode';
import type { Source } from '../constants.telemetry';
import type { Container } from '../container';
import { GitUri } from '../git/gitUri';
import type { GitBranch } from '../git/models/branch';
import type { GitBranchReference } from '../git/models/reference';
import { showGenericErrorMessage } from '../messages';
import { prepareCompareDataForAIRequest } from '../plus/ai/aiProviderService';
import { ReferencesQuickPickIncludes, showReferencePicker } from '../quickpicks/referencePicker';
import { getBestRepositoryOrShowPicker } from '../quickpicks/repositoryPicker';
import { command } from '../system/-webview/command';
import { showMarkdownPreview } from '../system/-webview/markdown';
import { Logger } from '../system/logger';
import { getNodeRepoPath } from '../views/nodes/abstract/viewNode';
import { GlCommandBase } from './commandBase';
import { getCommandUri } from './commandBase.utils';
import type { CommandContext } from './commandContext';
import { isCommandContextViewNodeHasBranch } from './commandContext.utils';

export interface ExplainBranchCommandArgs {
	repoPath?: string | Uri;
	ref?: string;
	source?: Source;
}

@command()
export class ExplainBranchCommand extends GlCommandBase {
	constructor(private readonly container: Container) {
		super(['gitlens.ai.explainBranch', 'gitlens.ai.explainBranch:views']);
	}

	protected override preExecute(context: CommandContext, args?: ExplainBranchCommandArgs): Promise<void> {
		if (isCommandContextViewNodeHasBranch(context)) {
			args = { ...args };
			args.repoPath = args.repoPath ?? getNodeRepoPath(context.node);
			args.ref = args.ref ?? context.node.branch.ref;
			args.source = args.source ?? { source: 'view' };
		}

		return this.execute(context.editor, context.uri, args);
	}

	async execute(editor?: TextEditor, uri?: Uri, args?: ExplainBranchCommandArgs): Promise<void> {
		args = { ...args };

		let repository;
		if (args?.repoPath != null) {
			repository = this.container.git.getRepository(args.repoPath);
		} else {
			uri = getCommandUri(uri, editor);
			const gitUri = uri != null ? await GitUri.fromUri(uri) : undefined;
			repository = await getBestRepositoryOrShowPicker(
				gitUri,
				editor,
				'Explain Branch',
				'Choose which repository to explain a branch from',
			);
		}

		if (repository == null) return;

		try {
			// Clarifying the head branch
			if (args.ref == null) {
				// If no ref is provided, show a picker to select a branch
				const pick = (await showReferencePicker(
					repository.path,
					'Explain Branch',
					'Choose a branch to explain',
					{
						include: ReferencesQuickPickIncludes.Branches,
						sort: { branches: { current: true } },
					},
				)) as GitBranchReference | undefined;
				if (pick?.ref == null) return;
				args.ref = pick.ref;
			}

			// Get the branch
			const branch = await repository.git.branches().getBranch(args.ref);
			if (branch == null) {
				void showGenericErrorMessage('Unable to find the specified branch');
				return;
			}

			// Clarifying the base branch
			const baseBranchName = await getMergeTarget(this.container, branch);
			const baseBranch = await repository.git.branches().getBranch(baseBranchName);
			if (!baseBranch) {
				void showGenericErrorMessage(`Unable to find the base branch for branch ${branch.name}.`);
				return;
			}

			// Get the diff between the branch and its upstream or base
			const compareData = await prepareCompareDataForAIRequest(repository, branch.ref, baseBranch.ref, {
				reportNoDiffService: () => void showGenericErrorMessage('Unable to get diff service'),
				reportNoCommitsService: () => void showGenericErrorMessage('Unable to get commits service'),
				reportNoChanges: () => void showGenericErrorMessage('No changes found to explain'),
			});

			if (compareData == null) {
				return;
			}

			const { diff, logMessages } = compareData;

			const changes = {
				diff: diff,
				message: `Changes in branch ${branch.name}
					that is ahead of its target by number of commits with the following messages:\n\n
					<commits>
					${logMessages}
					<end-of-commits>
					`,
			};

			// Call the AI service to explain the changes
			const result = await this.container.ai.explainChanges(
				changes,
				{
					...args.source,
					source: args.source?.source ?? 'commandPalette',
					type: 'branch',
				},
				{
					progress: { location: ProgressLocation.Notification, title: 'Explaining branch changes...' },
				},
			);

			if (result == null) {
				void showGenericErrorMessage(`Unable to explain branch ${branch.name}`);
				return;
			}

			const content = `# Branch Summary\n\n> Generated by ${result.model.name}\n\n## ${branch.name}\n\n${result.parsed.summary}\n\n${result.parsed.body}`;

			void showMarkdownPreview(content);
		} catch (ex) {
			Logger.error(ex, 'ExplainBranchCommand', 'execute');
			void showGenericErrorMessage('Unable to explain branch');
		}
	}
}

async function getMergeTarget(
	container: Container,
	branch: GitBranch,
	options?: { cancellation?: CancellationToken },
): Promise<string | undefined> {
	const localValue = await container.git
		.branches(branch.repoPath)
		.getBestMergeTargetBranchName?.(branch.name, branch.getRemoteName());
	if (localValue) return localValue;

	return getIntegrationDefaultBranchName(container, branch.repoPath, options);
}

// This is similar to what we have in changeBranchMergeTarget.ts
// what is a proper utils files to put it to?
async function getIntegrationDefaultBranchName(
	container: Container,
	repoPath: string,
	options?: { cancellation?: CancellationToken },
): Promise<string | undefined> {
	const remote = await container.git.remotes(repoPath).getBestRemoteWithIntegration();
	if (remote == null) return undefined;

	const integration = await remote.getIntegration();
	const defaultBranch = await integration?.getDefaultBranch?.(remote.provider.repoDesc, options);
	return defaultBranch && `${remote.name}/${defaultBranch?.name}`;
}
