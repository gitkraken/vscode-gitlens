import type { CancellationToken, TextEditor, Uri } from 'vscode';
import { ProgressLocation } from 'vscode';
import type { Container } from '../container';
import { GitUri } from '../git/gitUri';
import type { GitBranch } from '../git/models/branch';
import { showGenericErrorMessage } from '../messages';
import type { AIExplainSource } from '../plus/ai/aiProviderService';
import { ReferencesQuickPickIncludes, showReferencePicker } from '../quickpicks/referencePicker';
import { getBestRepositoryOrShowPicker } from '../quickpicks/repositoryPicker';
import { command } from '../system/-webview/command';
import { showMarkdownPreview } from '../system/-webview/markdown';
import { Logger } from '../system/logger';
import { getNodeRepoPath } from '../views/nodes/abstract/viewNode';
import { GlCommandBase } from './commandBase';
import { getCommandUri } from './commandBase.utils';
import type { CommandContext } from './commandContext';
import { isCommandContextViewNodeHasBranch } from './commandContext.utils';

export interface ExplainBranchCommandArgs {
	repoPath?: string | Uri;
	ref?: string;
	source?: AIExplainSource;
}

@command()
export class ExplainBranchCommand extends GlCommandBase {
	constructor(private readonly container: Container) {
		super('gitlens.ai.explainBranch');
	}

	protected override preExecute(context: CommandContext, args?: ExplainBranchCommandArgs): Promise<void> {
		if (isCommandContextViewNodeHasBranch(context)) {
			args = { ...args };
			args.repoPath = args.repoPath ?? getNodeRepoPath(context.node);
			args.ref = args.ref ?? context.node.branch.ref;
			args.source = args.source ?? { source: 'view', type: 'branch' };
		}

		return this.execute(context.editor, context.uri, args);
	}

	async execute(editor?: TextEditor, uri?: Uri, args?: ExplainBranchCommandArgs): Promise<void> {
		args = { ...args };

		let repository;
		if (args?.repoPath != null) {
			repository = this.container.git.getRepository(args.repoPath);
		} else {
			uri = getCommandUri(uri, editor);
			const gitUri = uri != null ? await GitUri.fromUri(uri) : undefined;
			repository = await getBestRepositoryOrShowPicker(
				gitUri,
				editor,
				'Explain Branch',
				'Choose which repository to explain a branch from',
			);
		}

		if (repository == null) return;

		try {
			//// Clarifying the head branch
			if (args.ref == null) {
				// If no ref is provided, show a picker to select a branch
				const pick = await showReferencePicker(
					repository.path,
					'Explain Branch',
					'Choose a branch to explain',
					{
						include: ReferencesQuickPickIncludes.Branches,
						sort: { branches: { current: true } },
					},
				);
				if (pick?.ref == null) return;
				args.ref = pick.ref;
			}

			// Get the branch
			const branch = await repository.git.branches().getBranch(args.ref);
			if (branch == null) {
				void showGenericErrorMessage('Unable to find the specified branch');
				return;
			}

			//// Clarifying the base branch
			const baseBranchName = await getMergeTarget(this.container, branch);
			const baseBranch = await repository.git.branches().getBranch(baseBranchName);
			if (!baseBranch) {
				void showGenericErrorMessage(
					'Unable to find the base branch for the specified branch. Probably it is undefined. Set it up and try again.',
				);
				return;
			}

			// Get the diff between the branch and its upstream or base
			const compareData = await this.container.ai.prepareCompareDataForAIRequest(
				repository,
				branch.ref,
				baseBranch.ref,
				{
					reportNoDiffService: () => void showGenericErrorMessage('Unable to get diff service'),
					reportNoCommitsService: () => void showGenericErrorMessage('Unable to get commits service'),
					reportNoChanges: () => void showGenericErrorMessage('No changes found to explain'),
				},
			);

			if (compareData == null) {
				return;
			}

			const { diff, logMessages } = compareData;

			const changes = {
				diff: diff,
				message: `Changes in branch ${branch.name}
					that is ahead of its target by number of commits with the following messages:\n\n
					<commits>
					${logMessages}
					<end-of-commits>
					`,
			};

			// Call the AI service to explain the changes
			const result = await this.container.ai.explainChanges(
				changes,
				args.source ?? { source: 'commandPalette', type: 'commit' },
				{
					progress: { location: ProgressLocation.Notification, title: 'Explaining branch changes...' },
				},
			);

			// Display the result
			let content = `# Branch: ${branch.name}\n`;
			if (result != null) {
				content += `> Generated by ${result.model.name}\n\n----\n\n${result?.parsed.summary}\n\n${result?.parsed.body}`;
			} else {
				content += `> No changes found to explain.`;
			}
			// Add changes temporarily for debug purposes, so it's easier to review what content has been explained
			const changesMd = `${changes.message}\n\n${changes.diff}`;
			void showMarkdownPreview(`${content}\n\n\`\`\`\n${changesMd.replaceAll('`', '')}\n\`\`\`\n`);
		} catch (ex) {
			Logger.error(ex, 'ExplainBranchCommand', 'execute');
			void showGenericErrorMessage('Unable to explain branch');
		}
	}
}

async function getMergeTarget(
	container: Container,
	branch: GitBranch,
	options?: { cancellation?: CancellationToken },
): Promise<string | undefined> {
	const localValue = await container.git.branches(branch.repoPath).getMergeTargetBranchName?.(branch);
	if (localValue) {
		return localValue;
	}
	return getIntegrationDefaultBranchName(container, branch.repoPath, options);
}

// This is similar to what we have in changeBranchMergeTarget.ts
// what is a proper utils files to put it to?
async function getIntegrationDefaultBranchName(
	container: Container,
	repoPath: string,
	options?: { cancellation?: CancellationToken },
): Promise<string | undefined> {
	const remote = await container.git.remotes(repoPath).getBestRemoteWithIntegration();
	if (remote == null) return undefined;

	const integration = await remote.getIntegration();
	const defaultBranch = await integration?.getDefaultBranch?.(remote.provider.repoDesc, options);
	return defaultBranch && `${remote.name}/${defaultBranch?.name}`;
}
