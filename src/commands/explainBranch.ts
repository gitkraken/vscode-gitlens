import type { CancellationToken, TextEditor, Uri } from 'vscode';
import { ProgressLocation } from 'vscode';
import type { Source } from '../constants.telemetry';
import type { Container } from '../container';
import { GitUri } from '../git/gitUri';
import type { GitBranch } from '../git/models/branch';
import { showGenericErrorMessage } from '../messages';
import type { AIExplainSource } from '../plus/ai/aiProviderService';
import { ReferencesQuickPickIncludes, showReferencePicker } from '../quickpicks/referencePicker';
import { getBestRepositoryOrShowPicker, getRepositoryOrShowPicker } from '../quickpicks/repositoryPicker';
import { command } from '../system/-webview/command';
import { showMarkdownPreview } from '../system/-webview/markdown';
import { Logger } from '../system/logger';
import { getSettledValue } from '../system/promise';
import { GlCommandBase } from './commandBase';
import { getCommandUri } from './commandBase.utils';
import type { CommandContext } from './commandContext';

export interface ExplainBranchCommandArgs {
	repoPath?: string | Uri;
	ref?: string;
	source?: AIExplainSource;
}

@command()
export class ExplainBranchCommand extends GlCommandBase {
	constructor(private readonly container: Container) {
		super('gitlens.ai.explainBranch');
	}

	protected override preExecute(context: CommandContext, args?: ExplainBranchCommandArgs): Promise<void> {
		return this.execute(context.editor, context.uri, args);
	}

	async execute(editor?: TextEditor, uri?: Uri, args?: ExplainBranchCommandArgs): Promise<void> {
		//// Clarifying the repository
		uri = getCommandUri(uri, editor);
		const gitUri = uri != null ? await GitUri.fromUri(uri) : undefined;
		const repository = await getBestRepositoryOrShowPicker(
			gitUri,
			editor,
			'Explain Branch',
			'Choose which repository to explain a branch from',
		);
		if (repository == null) return;

		args = { ...args };

		try {
			//// Clarifying the head branch
			if (args.ref == null) {
				// If no ref is provided, show a picker to select a branch
				const pick = await showReferencePicker(
					repository.path,
					'Explain Branch',
					'Choose a branch to explain',
					{
						include: ReferencesQuickPickIncludes.Branches,
						sort: { branches: { current: true } },
					},
				);
				if (pick?.ref == null) return;
				args.ref = pick.ref;
			}

			// Get the branch
			const branch = await repository.git.branches().getBranch(args.ref);
			if (branch == null) {
				void showGenericErrorMessage('Unable to find the specified branch');
				return;
			}

			//// Clarifying the base branch
			const baseBranchName = await getMergeTarget(this.container, branch);
			const baseBranch = await repository.git.branches().getBranch(baseBranchName);
			if (!baseBranch) {
				void showGenericErrorMessage(
					'Unable to find the base branch for the specified branch. Probably it is undefined. Set it up and try again.',
				);
				return;
			}

			// Get the diff between the branch and its upstream or base
			const diffService = repository.git.diff();
			if (diffService?.getDiff === undefined) {
				void showGenericErrorMessage('Unable to get diff service');
				return;
			}

			const commitsService = repository.git.commits();
			if (commitsService?.getLog === undefined) {
				void showGenericErrorMessage('Unable to get commits service');
				return;
			}

			const [diffResult, logResult] = await Promise.allSettled([
				diffService.getDiff?.(branch.ref, baseBranch.ref, { notation: '...' }),
				commitsService.getLog(`${baseBranch.ref}..${branch.ref}`),
			]);

			const diff = getSettledValue(diffResult);
			const log = getSettledValue(logResult);
			if (!diff?.contents || !log?.commits?.size) {
				void showGenericErrorMessage('No changes found to explain');
				return;
			}

			const commitMessages: string[] = [];
			for (const commit of [...log.commits.values()].sort((a, b) => a.date.getTime() - b.date.getTime())) {
				const message = commit.message ?? commit.summary;
				if (message) {
					commitMessages.push(
						`<commit-message ${commit.date.toISOString()}>\n${
							commit.message ?? commit.summary
						}\n<end-of-commit-message>`,
					);
				}
			}

			const changes = {
				diff: diff.contents,
				message: `Changes in branch ${branch.name}
					that is ahead of its target by number of commits with the following messages:\n\n
					<commits>
					${commitMessages.join('\n\n')}
					<end-of-commits>
					`,
			};

			// Call the AI service to explain the changes
			const result = await this.container.ai.explainChanges(
				changes,
				args.source ?? { source: 'commandPalette', type: 'commit' },
				{
					progress: { location: ProgressLocation.Notification, title: 'Explaining branch changes...' },
				},
			);

			// Display the result
			let content = `# Branch: ${branch.name}\n`;
			if (result != null) {
				content += `> Generated by ${result.model.name}\n\n----\n\n${result?.parsed.summary}\n\n${result?.parsed.body}`;
			} else {
				content += `> No changes found to explain.`;
			}
			// Add changes temporarily for debug purposes, so it's easier to review what content has been explained
			const changesMd = `${changes.message}\n\n${changes.diff}`;
			void showMarkdownPreview(`${content}\n\n\`\`\`\n${changesMd.replaceAll('`', '')}\n\`\`\`\n`);
		} catch (ex) {
			Logger.error(ex, 'ExplainBranchCommand', 'execute');
			void showGenericErrorMessage('Unable to explain branch');
		}
	}
}

export interface ExplainBranchCommandArgs2 {
	repoPath: string;
	branch: string;
	source?: Source;
}

@command()
export class ExplainBranchCommand2 extends GlCommandBase {
	constructor(private readonly container: Container) {
		super('gitlens.ai.explainBranch');
	}

	async execute(args?: ExplainBranchCommandArgs2): Promise<void> {
		let repo;
		if (args?.repoPath != null) {
			repo = this.container.git.getRepository(args.repoPath);
		}
		repo ??= await getRepositoryOrShowPicker(
			'Explain Branch',
			'Choose which repository to explain a branch from',
			undefined,
		);
		if (repo == null) return;

		try {
			// If no ref is provided, show a picker to select a branch
			if (args == null) {
				const pick = await showReferencePicker(repo.path, 'Explain Branch', 'Choose a branch to explain', {
					include: ReferencesQuickPickIncludes.Branches,
					sort: { branches: { current: true } },
				});
				if (pick?.ref == null) return;

				args = {
					repoPath: repo.path,
					branch: pick.ref,
				};
			}

			// Get the branch
			const branch = await repo.git.branches().getBranch(args.branch);
			if (branch == null) {
				void showGenericErrorMessage('Unable to find the specified branch');
				return;
			}
			const headRef = branch.ref;
			const baseRef = branch.upstream?.name;

			// Get the diff between the branch and its upstream or base
			const [diffResult, logResult] = await Promise.allSettled([
				repo.git.diff().getDiff?.(headRef, baseRef, { notation: '...' }),
				repo.git.commits().getLog(`${baseRef}..${headRef}`),
			]);

			const diff = getSettledValue(diffResult);
			const log = getSettledValue(logResult);

			if (!diff?.contents || !log?.commits?.size) {
				void showGenericErrorMessage('No changes found to explain');
			}
		} catch (ex) {
			Logger.error(ex, 'ExplainBranchCommand', 'execute');
			void showGenericErrorMessage('Unable to explain branch');
		}
	}
}

// export interface ExplainBranchCommandArgs {
// 	repoPath: string;
// 	branch: GitBranchReference;
// 	source?: Source;
// }

// @command()
// export class ExplainBranchCommand extends GlCommandBase {
// 	constructor(private readonly container: Container) {
// 		super('gitlens.ai.explainBranch');
// 	}

// 	async execute(args?: ExplainBranchCommandArgs): Promise<void> {
// 		try {
// 			// I'm declining it for now, because it can be a behaviour for "explain comparison" command,
// 			// that can be called either from the command palette or from the compare view.
// 			const comparisonResult = await showComparisonPicker(this.container, args?.repoPath, {
// 				head: args?.branch,
// 				getTitleAndPlaceholder: step => {
// 					switch (step) {
// 						case 1:
// 							return {
// 								title: 'Explain Branch',
// 								placeholder: 'Choose a branch to explain',
// 							};
// 						case 2:
// 							return {
// 								title: `Explain Branch \u2022 Select Base to Start From`,
// 								placeholder: 'Choose a base branch to explain from',
// 							};
// 					}
// 				},
// 			});
// 			if (comparisonResult == null) return;

// 			const repo = this.container.git.getRepository(comparisonResult.repoPath);
// 			if (repo == null) return;

// 			const mergeBase = await repo.git.refs().getMergeBase(comparisonResult.head.ref, comparisonResult.base.ref);

// 			const [diffResult, logResult] = await Promise.allSettled([
// 				repo.git.diff().getDiff?.(comparisonResult.head.ref, mergeBase, { notation: '...' }),
// 				repo.git.commits().getLog(`${mergeBase}..${comparisonResult.head.ref}`),
// 			]);

// 			const diff = getSettledValue(diffResult);
// 			const log = getSettledValue(logResult);

// 			if (!diff?.contents || !log?.commits?.size) {
// 				void showGenericErrorMessage('No changes found to explain');
// 				return;
// 			}

// 			const commitMessages: string[] = [];
// 			for (const commit of [...log.commits.values()].sort((a, b) => a.date.getTime() - b.date.getTime())) {
// 				commitMessages.push(commit.message ?? commit.summary);
// 			}

// 			const result = await this.container.ai.explainChanges(
// 				{
// 					diff: diff.contents,
// 					message: commitMessages.join('\n\n'),
// 				},
// 				{
// 					source: 'commandPalette',
// 					...args?.source,
// 					type: 'branch',
// 				},
// 				{
// 					progress: { location: ProgressLocation.Notification, title: 'Explaining branch changes...' },
// 				},
// 			);

// 			// Display the result
// 			let content = `# Branch: ${comparisonResult.head.name}\n`;
// 			if (result != null) {
// 				content += `> Generated by ${result.model.name}\n\n----\n\n${result?.parsed.summary}\n\n${result?.parsed.body}`;
// 			} else {
// 				content += `> No changes found to explain.`;
// 			}
// 			void showMarkdownPreview(content);
// 		} catch (ex) {
// 			Logger.error(ex, 'ExplainBranchCommand', 'execute');
// 			void showGenericErrorMessage('Unable to explain branch');
// 		}
// 	}
// }

async function getMergeTarget(
	container: Container,
	branch: GitBranch,
	options?: { cancellation?: CancellationToken },
): Promise<string | undefined> {
	const localValue = await container.git.branches(branch.repoPath).getMergeTargetBranchName?.(branch);
	if (localValue) {
		return localValue;
	}
	return getIntegrationDefaultBranchName(container, branch.repoPath, options);
}

// This is similar to what we have in changeBranchMergeTarget.ts
// what is a proper utils files to put it to?
async function getIntegrationDefaultBranchName(
	container: Container,
	repoPath: string,
	options?: { cancellation?: CancellationToken },
): Promise<string | undefined> {
	const remote = await container.git.remotes(repoPath).getBestRemoteWithIntegration();
	if (remote == null) return undefined;

	const integration = await remote.getIntegration();
	const defaultBranch = await integration?.getDefaultBranch?.(remote.provider.repoDesc, options);
	return defaultBranch && `${remote.name}/${defaultBranch?.name}`;
}
